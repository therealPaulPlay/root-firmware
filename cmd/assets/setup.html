<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ROOT setup</title>
    <style>
        @font-face {
            font-family: "Clash Display";
            src: url("/fonts/clash-display-variable.woff2") format("woff2");
            font-weight: 100 900;
        }

        @font-face {
            font-family: "Commit Mono";
            src: url("/fonts/commit-mono-variable.woff2") format("woff2");
            font-weight: 100 900;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: "Commit Mono", monospace;
            background: #fff;
            color: #000;
            padding: 20px;
            max-width: 600px;
            margin: 0 auto;
        }

        .section {
            margin-bottom: 30px;
            padding: 20px;
            border: 1px solid #bcbcbc;
            display: none;
        }

        .section.active {
            display: block;
        }

        h2 {
            font-family: "Clash Display", sans-serif;
            font-size: 18px;
            margin-bottom: 25px;
            text-transform: uppercase;
            font-weight: 500;
            /* Tracking wide */
            letter-spacing: 0.025em;
        }

        label {
            display: block;
            margin-bottom: 5px;
            font-size: 12px;
            text-transform: uppercase;
        }

        input,
        select {
            width: 100%;
            padding: 10px;
            margin-bottom: 15px;
            border: 1px solid #bcbcbc;
            background: #fff;
            font-family: "Commit Mono", monospace;
            font-size: 14px;
        }

        input:focus,
        select:focus {
            outline: 2px solid #000;
        }

        input[readonly] {
            opacity: 0.5;
            pointer-events: none;
        }

        button {
            padding: 10px 20px;
            border: 1px solid #000;
            text-transform: uppercase;
            background: #000;
            color: #fff;
            font-family: "Commit Mono", monospace;
            font-size: 14px;
            cursor: pointer;
        }

        button:hover {
            background: #fff;
            color: #000;
        }

        button:disabled {
            opacity: 0.3;
            cursor: not-allowed;
        }

        button.secondary {
            background: #fff;
            color: #000;
        }

        button.secondary:hover {
            background: #000;
            color: #fff;
        }

        .inline-group {
            display: flex;
            gap: 10px;
            align-items: end;
            margin-bottom: 15px;
        }

        .inline-group input {
            margin-bottom: 0;
        }

        .inline-group>div {
            flex: 1;
        }

        .warning {
            margin-bottom: 15px;
            padding: 10px;
            border: 1px solid #bcbcbc;
            font-size: 12px;
        }

        .error {
            color: #000;
            background: #f0f0f0;
            padding: 10px;
            border: 1px solid #000;
            margin-bottom: 15px;
            font-size: 12px;
        }

        .success {
            padding: 10px;
            border: 1px solid #000;
            margin-bottom: 15px;
            font-size: 12px;
        }

        .checkbox-group {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 15px;
        }

        .checkbox-group input[type="checkbox"] {
            width: 18px;
            height: 18px;
            margin: 0;
            appearance: none;
            border: 1px solid #000;
            background: #fff;
            cursor: pointer;
        }

        .checkbox-group input[type="checkbox"]:checked {
            background: #000;
            box-shadow: inset 0 0 0 2px #fff, inset 0 0 0 3px #000;
        }

        .checkbox-group input[type="checkbox"]:focus {
            outline: 2px solid #000;
            outline-offset: 2px;
        }

        .checkbox-group label {
            margin: 0;
            text-transform: none;
            cursor: pointer;
        }

        .instructions {
            padding: 15px;
            border: 1px solid #bcbcbc;
            margin-bottom: 15px;
            font-size: 14px;
            line-height: 1.6;
        }

        #device-id {
            font-size: 10px;
            opacity: 0.5;
            margin-bottom: 25px;
            margin-left: 1px;
        }

        #device-name {
            margin-bottom: 5px;
        }

        #relay-config-container.locked {
            opacity: 0.5;
            pointer-events: none;
        }
    </style>
</head>

<body>
    <!-- Step 1: Pairing -->
    <div class="section active" id="step-pairing">
        <h2>1. Pair your device</h2>
        <div id="pairing-error" class="error" style="display:none;"></div>

        <label>Device name</label>
        <input type="text" id="device-name" placeholder="My phone">
        <p id="device-id"></p>

        <div class="inline-group">
            <div>
                <label>Pairing code</label>
                <input type="text" id="pairing-code" placeholder="000000" maxlength="6">
            </div>
            <button class="secondary wait-for-request" onclick="speakCode()">Speak code</button>
        </div>

        <button class="wait-for-request" onclick="pair()">Pair</button>
    </div>

    <!-- Step 2: WiFi Setup -->
    <div class="section" id="step-wifi">
        <h2>2. Connect to WiFi</h2>
        <div id="wifi-error" class="error" style="display:none;"></div>

        <label>Network</label>
        <select id="wifi-network">
            <option value="">Select network</option>
        </select>

        <label>Password</label>
        <input type="password" id="wifi-password" placeholder="ABCD1234">

        <div style="display: flex; gap: 10px;">
            <button id="wifi-keep-btn" class="wait-for-request" onclick="skipWifi()" style="display:none;">Continue</button>
            <button id="wifi-connect-btn" class="wait-for-request" onclick="connectWifi()">Connect</button>
        </div>
    </div>

    <!-- Step 3: Relay Server -->
    <div class="section" id="step-relay">
        <h2>3. Set relay server</h2>
        <div id="relay-error" class="error" style="display:none;"></div>

        <div id="relay-locked-message" class="warning" style="display:none;">
            Relay server already configured.
        </div>

        <div id="relay-config-container">
            <div class="checkbox-group">
                <input type="checkbox" id="use-default-relay" checked onchange="toggleRelayInput()">
                <label for="use-default-relay">Use official</label>
            </div>

            <div id="custom-relay-container" style="display:none;">
                <label>Relay server domain</label>
                <input type="text" id="relay-domain" value="Default">

                <div class="warning">
                    Warning: Using a custom relay server is not recommended. It is required to change it in the
                    dashboard as
                    well.
                </div>
            </div>

            <button class="wait-for-request" onclick="setRelay()" id="set-relay-button">Set (Default)</button>
        </div>
    </div>

    <!-- Step 4: Complete -->
    <div class="section" id="step-complete">
        <h2>4. Set up ROOT Connect</h2>

        <div class="instructions">
            1. Do not close or reload this page
            <br>
            2. Connect your device back to your regular WiFi network
            <br>
            3. Click "Add to ROOT Connect"
        </div>

        <button onclick="openRootConnect()">Add to ROOT Connect</button>
    </div>

    <script>
        const RELAY_SERVER_DOMAIN = "relay.rootprivacy.com";

        const deviceId = crypto.randomUUID();
        document.getElementById("device-id").textContent = "DEVICE ID: " + deviceId;

        let devicePrivateKey, devicePublicKey;

        async function generateKeypair() {
            const keyPair = await crypto.subtle.generateKey(
                { name: "ECDH", namedCurve: "P-256" },
                true,
                ["deriveKey", "deriveBits"]
            );

            devicePrivateKey = await crypto.subtle.exportKey("jwk", keyPair.privateKey);
            const publicKeyRaw = await crypto.subtle.exportKey("raw", keyPair.publicKey);
            devicePublicKey = base64Encode(new Uint8Array(publicKeyRaw));
        }

        generateKeypair();

        let cameraPublicKey = "";
        let sharedSecret;

        // Initialize relay input visibility on page load (in case browser cached checkbox state)
        window.addEventListener('DOMContentLoaded', () => {
            toggleRelayInput();
        });

        function base64Encode(bytes) {
            return btoa(String.fromCharCode(...bytes));
        }

        function base64Decode(str) {
            return Uint8Array.from(atob(str), c => c.charCodeAt(0));
        }

        async function postJSON(url, body) {
            // Disable all request buttons
            const buttons = document.querySelectorAll('.wait-for-request');
            buttons.forEach(btn => btn.disabled = true);

            try {
                const res = await fetch(url, {
                    method: "POST",
                    headers: { "Content-Type": "application/json" },
                    body: JSON.stringify(body)
                });

                let data;
                try { data = await res.json(); } catch {
                    throw new Error(`Request failed with status ${res.status}`);
                }

                // If we have JSON, check success field
                if (!data.success) throw new Error(data.error || `Request failed with status ${res.status}`);
                return data;
            } finally {
                // Re-enable all request buttons
                buttons.forEach(btn => btn.disabled = false);
            }
        }

        async function speakCode() {
            try {
                const res = await fetch("/get-code", { method: "POST" });
                if (!res.ok) throw new Error("Request failed with status " + res.status);
            } catch (err) {
                showError("pairing", "Failed to speak code: " + err.message);
            }
        }

        async function pair() {
            const deviceName = document.getElementById("device-name").value.trim();
            const code = document.getElementById("pairing-code").value.trim();

            if (!deviceName || !code) {
                showError("pairing", "Please fill in all fields!");
                return;
            }

            try {
                const data = await postJSON("/pair", {
                    deviceId,
                    deviceName,
                    code,
                    devicePublicKey
                });

                cameraPublicKey = data.data.cameraPublicKey;
                const relayDomain = data.data.relayDomain || RELAY_SERVER_DOMAIN;

                // Update relay input state to match currently selected one
                document.getElementById("relay-domain").value = relayDomain;

                // Update checkbox state based on whether it's default or custom
                const isDefaultRelay = relayDomain === RELAY_SERVER_DOMAIN;
                document.getElementById("use-default-relay").checked = isDefaultRelay;
                toggleRelayInput();

                // Check if relay domain is already configured
                const relayAlreadySet = data.data.relayDomain && data.data.relayDomain !== "";
                if (relayAlreadySet) {
                    document.getElementById("relay-config-container").classList.add("locked");
                    document.getElementById("relay-locked-message").style.display = "block";
                    document.getElementById("set-relay-button").textContent = "Continue";
                } else {
                    document.getElementById("set-relay-button").textContent = "Set";
                }

                const networks = data.data.availableNetworks || [];
                const currentWifi = data.data.currentWifiSSID;
                const select = document.getElementById("wifi-network");
                select.innerHTML = "<option value=\"\">Select network...</option>";

                networks.forEach(net => {
                    const option = document.createElement("option");
                    option.value = net.ssid;
                    option.textContent = `${net.ssid} (${net.signal})`;
                    if (currentWifi && net.ssid === currentWifi) {
                        option.selected = true;
                    }
                    select.appendChild(option);
                });

                // Show "Keep / Continue" button if already connected
                if (data.data.wifiConnected && currentWifi) {
                    document.getElementById("wifi-keep-btn").style.display = "block";
                    document.getElementById("wifi-connect-btn").classList.add("secondary");
                }

                hideError("pairing");
                showStep("step-wifi");
            } catch (err) {
                showError("pairing", err.message);
            }
        }

        async function deriveSharedSecret() {
            const privateKey = await crypto.subtle.importKey(
                "jwk",
                devicePrivateKey,
                { name: "ECDH", namedCurve: "P-256" },
                false,
                ["deriveKey", "deriveBits"]
            );

            const publicKey = await crypto.subtle.importKey(
                "raw",
                base64Decode(cameraPublicKey),
                { name: "ECDH", namedCurve: "P-256" },
                false,
                []
            );

            sharedSecret = await crypto.subtle.deriveKey(
                { name: "ECDH", public: publicKey },
                privateKey,
                { name: "AES-GCM", length: 256 },
                true,
                ["encrypt", "decrypt"]
            );
        }

        async function encryptPayload(payload) {
            if (!sharedSecret) await deriveSharedSecret();

            const iv = crypto.getRandomValues(new Uint8Array(12));
            const encodedPayload = new TextEncoder().encode(JSON.stringify(payload));

            const encrypted = await crypto.subtle.encrypt(
                { name: "AES-GCM", iv },
                sharedSecret,
                encodedPayload
            );

            // Prepend IV to ciphertext
            const combined = new Uint8Array(iv.length + encrypted.byteLength);
            combined.set(iv);
            combined.set(new Uint8Array(encrypted), iv.length);

            return base64Encode(combined);
        }

        async function connectWifi() {
            const ssid = document.getElementById("wifi-network").value;
            const password = document.getElementById("wifi-password").value;

            if (!ssid || !password) {
                showError("wifi", "Please select a network and enter a password!");
                return;
            }

            try {
                const encryptedPayload = await encryptPayload({ deviceId, ssid, password });
                await postJSON("/set-wifi", { deviceId, encryptedPayload });

                hideError("wifi");
                showStep("step-relay");
            } catch (err) {
                showError("wifi", err.message);
            }
        }

        function skipWifi() {
            showStep("step-relay");
        }

        function toggleRelayInput() {
            const checkbox = document.getElementById("use-default-relay");
            const container = document.getElementById("custom-relay-container");

            if (checkbox.checked) {
                container.style.display = "none";
            } else {
                container.style.display = "block";
                document.getElementById("relay-domain").focus();
            }
        }

        async function setRelay() {
            if (document.getElementById("relay-config-container").classList.contains("locked")) return; // If locked (= already set), skip

            const checkbox = document.getElementById("use-default-relay");
            const relayDomain = checkbox.checked
                ? RELAY_SERVER_DOMAIN
                : document.getElementById("relay-domain").value.trim();

            if (!relayDomain) {
                showError("relay", "Please enter relay server domain!");
                return;
            }

            try {
                const encryptedPayload = await encryptPayload({ deviceId, relayDomain });
                await postJSON("/set-relay", { deviceId, encryptedPayload });

                hideError("relay");
                showStep("step-complete");
            } catch (err) {
                showError("relay", err.message);
            }
        }

        function openRootConnect() {
            const privateKeyStr = JSON.stringify(devicePrivateKey);
            const url = `https://rootprivacy.com/connect?observer-setup=true&device-id=${encodeURIComponent(deviceId)}&root-public-key=${encodeURIComponent(cameraPublicKey)}&device-private-key=${encodeURIComponent(privateKeyStr)}`;
            window.location.href = url;
        }

        function showStep(stepId) {
            document.querySelectorAll(".section").forEach(s => s.classList.remove("active"));
            document.getElementById(stepId).classList.add("active");
        }

        function showError(section, message) {
            const errorEl = document.getElementById(section + "-error");
            errorEl.textContent = message;
            errorEl.style.display = "block";
        }

        function hideError(section) {
            document.getElementById(section + "-error").style.display = "none";
        }
    </script>
</body>

</html>